package com.scalableminds.util.mvc

import akka.stream.scaladsl.Source
import akka.util.ByteString
import com.scalableminds.util.tools.{BoxImplicits, Fox, FoxImplicits}
import net.liftweb.common.{Full, _}
import play.api.http.Status._
import play.api.http.{HeaderNames, HttpEntity, Status, Writeable}
import play.api.i18n.{I18nSupport, Messages, MessagesProvider}
import play.api.libs.iteratee.Enumerator
import play.api.libs.json._
import play.api.mvc.{Request, ResponseHeader, Result}
import play.twirl.api._

import scala.concurrent.{ExecutionContext, Future}

trait ResultBox extends I18nSupport with Formatter {

  def asResult[T <: Result](b: Box[T])(implicit messages: MessagesProvider): Result = b match {
    case Full(result) =>
      result
    case ParamFailure(msg, _, chain, statusCode: Int) =>
      new JsonResult(statusCode)(Messages(msg), formatChainOpt(chain))
    case ParamFailure(msg, _, _, msgs: JsArray) =>
      new JsonResult(BAD_REQUEST)(jsonMessages(msgs))
    case Failure(msg, _, chain) =>
      new JsonResult(BAD_REQUEST)(Messages(msg), formatChainOpt(chain))
    case Empty =>
      new JsonResult(NOT_FOUND)("Couldn't find the requested resource.")
  }

  def formatChainOpt(chain: Box[Failure])(implicit messages: MessagesProvider): Option[String] = chain match {
    case Full(failure) => Some(formatChain(chain))
    case _             => None
  }

  private def formatChain(chain: Box[Failure], includeTime: Boolean = true)(
      implicit messages: MessagesProvider): String = chain match {
    case Full(failure) =>
      val serverTimeMsg = if (includeTime) "[Server Time " + formatDate(System.currentTimeMillis()) + "] " else ""
      serverTimeMsg + " <~ " + Messages(failure.msg) + formatChain(failure.chain, includeTime = false)
    case _ => ""
  }

  def jsonMessages(msgs: JsArray)(implicit messages: MessagesProvider): JsObject =
    Json.obj("messages" -> msgs)
}

trait ResultImplicits extends ResultBox with I18nSupport {

  implicit def fox2FutureResult[T <: Result](b: Fox[T])(implicit ec: ExecutionContext,
                                                        messages: MessagesProvider): Future[Result] =
    b.futureBox.map(asResult)

  implicit def futureBox2Result[T <: Result](b: Box[Future[T]])(implicit ec: ExecutionContext,
                                                                messages: MessagesProvider): Future[Result] =
    b match {
      case Full(f) =>
        f.map(value => asResult(Full(value)))
      case Empty =>
        Future.successful(asResult(Empty))
      case f: Failure =>
        Future.successful(asResult(f))
    }

  implicit def boxFuture2Result[T <: Result](f: Future[Box[T]])(implicit ec: ExecutionContext,
                                                                messages: MessagesProvider): Future[Result] =
    f.map { b =>
      asResult(b)
    }

  implicit def box2Result[T <: Result](b: Box[T])(implicit messages: MessagesProvider): Result =
    asResult(b)

}

class JsonResult(status: Int)
    extends Result(header = ResponseHeader(status), body = HttpEntity.NoEntity)
    with JsonResultAttribues {

  val isSuccess = List(OK) contains status

  def createResult(content: JsObject)(implicit writeable: Writeable[JsObject]) =
    Result(header = ResponseHeader(status),
           body = HttpEntity.Strict(writeable.transform(content), writeable.contentType))

  def messageTypeFromStatus =
    if (isSuccess)
      jsonSuccess
    else
      jsonError

  def apply(json: JsObject) =
    createResult(json)

  def apply(json: JsObject, messages: Seq[(String, String)]) =
    createResult(json ++ jsonMessages(messages))

  def apply(messages: Seq[(String, String)]): Result =
    apply(Json.obj(), messages)

  def apply(html: Html, json: JsObject, messages: Seq[(String, String)]): Result =
    apply(json ++ jsonHTMLResult(html), messages)

  def apply(html: Html, json: JsObject, message: String): Result =
    apply(json ++ jsonHTMLResult(html), Seq(messageTypeFromStatus -> message))

  def apply(json: JsObject, message: String): Result =
    apply(json, Seq(messageTypeFromStatus -> message))

  def apply(html: Html, messages: Seq[(String, String)]): Result =
    apply(html, Json.obj(), messages)

  def apply(html: Html, message: String, chain: Option[String]): Result =
    apply(html, Seq(messageTypeFromStatus -> message) ++ namedChain(chain))

  def apply(html: Html): Result =
    apply(html, Seq.empty)

  def apply(message: String, chain: Option[String] = None): Result =
    apply(Html(""), message, chain)

  def namedChain(chainOpt: Option[String]) = chainOpt match {
    case None        => None
    case Some(chain) => Some("chain" -> chain)
  }

  def jsonHTMLResult(html: Html): JsObject = {
    val htmlJson = html.body match {
      case "" =>
        Json.obj()
      case body =>
        Json.obj("html" -> body)
    }

    htmlJson
  }

  def jsonMessages(messages: Seq[(String, String)]): JsObject =
    Json.obj("messages" -> messages.map(m => Json.obj(m._1 -> m._2)))
}

trait JsonResults extends JsonResultAttribues {
  val JsonOk = new JsonResult(OK)
  val JsonBadRequest = new JsonResult(BAD_REQUEST)
}

trait JsonResultAttribues {
  val jsonSuccess = "success"
  val jsonError = "error"
}

trait PostRequestHelpers {
  def postParameter(parameter: String)(implicit request: Request[Map[String, Seq[String]]]) =
    request.body.get(parameter).flatMap(_.headOption)

  def postParameterList(parameter: String)(implicit request: Request[Map[String, Seq[String]]]) =
    request.body.get(parameter)
}

trait ExtendedController
    extends JsonResults
    with BoxImplicits
    with FoxImplicits
    with ResultImplicits
    with Status
    with WithHighlightableResult
    with PostRequestHelpers
    with WithFilters
    with I18nSupport
